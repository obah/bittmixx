{"noir_version":"1.0.0-beta.5+c651df6e2bf5db3966aa0c95abea2fc4c69d4513","hash":"1891198181337477069","abi":{"parameters":[{"name":"root_hash","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_hash","type":{"kind":"field"},"visibility":"public"},{"name":"recipient_address","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_proof","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"is_even","type":{"kind":"array","length":20,"type":{"kind":"boolean"}},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"13235270398509308954":{"error_kind":"string","string":"Invalid nullifier hash"},"13410961693771009187":{"error_kind":"string","string":"Invalid merkle proof"}}},"bytecode":"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","debug_symbols":"pdfLbuowEAbgd8mahWfs8aWvcnRUBQhVpCigFCodob77ceg/XBaOKF7NQJgP2xlbybnZduvTx3s/7vafzdufc7Oe+mHoP96H/aY99vsxf3v+XjX68f04dV3+qrm7nqsO7dSNx+ZtPA3Dqvlqh9PlR5+HdrzEYzvlq2bVdOM2xwzu+qGbs+/VrdqUSy05FFu5lctjPS3UC6Pekb/Vx4d6LtczxwSAreGSYMsCkdchEEV5ZQyBvI4hWFMSZGEMIVgdQ0jFWfiykJwASLno9/Vk+LoKxssrc0hG7wQlLs5hqZeSu/aCK/aSqWwmWuhG9lH3Avtki8RCM5C9LYPl4q0gW3kvF9chxes6yEvr8FxHk69uaQrVPbk4iuqmdHxdS59KTblQL1Y7SlIo1fNiT/L1VtxNgJ4G8rGoRzSFV4DcRLoEtgy42kNeqk959vXHvFTvirlhKncFp8rTYQl4clstTqN6W/n5+LkA3j2e9X/zp3bTTw9POg2b5i0PiOkncP7jOVpEhyh53Plf2c/NnmNAjIjpJ1qDSIiMaBEdoiDCs/AsPAvPwXPwHDwHz8Fz8Bw8B8/Bc/AEnsATeAJP4Ak8gSfwBJ7A8/A8PA/Pw/PwPDwPz8Pz8Dy8AC/AC/ACvAAvwAvwArwAL8CL8CK8CC/Ci/AivAgvwovwIrwEL8FL8BK8BC/BS/ASvAQvwSNjNCFNWBOridNENPGaBE2iJiqTyqQyqUwqk8qkMqlMKpPKpDKrzCqzyqwyq8wq69ahy96ZH4G+2qlv10OHN47dadzcvYAc/x30ir6iHKb9ptuepm7ewpdreVP/Bw==","file_map":{"50":{"source":"use dep::poseidon::poseidon2::Poseidon2::hash;\n\nmod merkle_root;\n\nfn main(\n    root_hash: pub Field,\n    nullifier_hash: pub Field,\n    recipient_address: pub Field,\n    nullifier: Field,\n    secret: Field,\n    merkle_proof: [Field; 20],\n    is_even: [bool; 20],\n    amount: Field,\n) {\n    let commitment: Field = hash([nullifier, secret, amount], 3);\n\n    let computed_nullifier_hash: Field = hash([nullifier], 1);\n\n    assert(computed_nullifier_hash == nullifier_hash, \"Invalid nullifier hash\");\n\n    let computed_merkle_root = merkle_root::compute_merkle_root(commitment, merkle_proof, is_even);\n\n    assert(computed_merkle_root == root_hash, \"Invalid merkle proof\");\n}\n","path":"/Users/obaloluwa/Documents/WEB3 & ZK/Starknet/bittmixx-2/packages/circuits/src/main.nr"},"51":{"source":"use dep::poseidon::poseidon2::Poseidon2::hash;\n\npub(crate) fn compute_merkle_root(\n    leaf: Field,\n    merkle_proof: [Field; 20],\n    is_even: [bool; 20],\n) -> Field {\n    let mut current_hash: Field = leaf;\n\n    for i in 0..20 {\n        let (left, right) = if is_even[i] {\n            (current_hash, merkle_proof[i])\n        } else {\n            (merkle_proof[i], current_hash)\n        };\n\n        current_hash = hash([left, right], 2);\n    }\n\n    current_hash\n}\n","path":"/Users/obaloluwa/Documents/WEB3 & ZK/Starknet/bittmixx-2/packages/circuits/src/merkle_root.nr"},"58":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/obaloluwa/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":[]}