{"noir_version":"1.0.0-beta.5+c651df6e2bf5db3966aa0c95abea2fc4c69d4513","hash":"14047665933563753403","abi":{"parameters":[{"name":"root_hash","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_hash","type":{"kind":"field"},"visibility":"public"},{"name":"recipient_address","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_proof","type":{"kind":"array","length":32,"type":{"kind":"field"}},"visibility":"private"},{"name":"is_even","type":{"kind":"array","length":32,"type":{"kind":"boolean"}},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"13235270398509308954":{"error_kind":"string","string":"Invalid nullifier hash"},"13410961693771009187":{"error_kind":"string","string":"Invalid merkle proof"}}},"bytecode":"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","debug_symbols":"pZfLbuJAEEX/xWsWvtXuV35lNIoc4kRIlkEORBpF+fdpk3shLGwleFUFpg7d7Tol+6N67p5Or4+74WX/Vj38+aiexl3f714f+/22Pe72Q/n243NT6ePjcey68lX17XqpOrRjNxyrh+HU95vqve1P5x+9HdrhHI/tWK7Wm6obnksswJdd303Z5+ZaXc+XOjQsdv5a7m/rsVDvjfUNwrU+3dTbfL1ZygSYq22O4OYJQNASgOTvWUNE0Bqiq+cIfmENMTqtIebZXYR5Qm48AbkU/b4etV1OoQ7+nj3kWncC2Wb3sNRLubn0QjPbS/XKZsJCN1pIcsFCdrOIhWaAux6Ds9lbAbfyXi6eQ06Xc/B3ncPPOhphdUsjru7JxVWsbsrGLmcZ8lxTLtR7p47yOc7V22JP2uVWfNsAfgwoY1EjGvEeQGkiHYGbBzRrh7xfPeUtrB/zfrUVU8OstMLyyumwBPihVovbWK1VmMbPGRCa21n/t3xqt7vx5kmnclY9lAU59xWa8sdT9IyBMZZ1l391aWr2EvNXbGpGMBqjY2wYPWNgjIzkNeR58jx5njxPnifPk+fJ8+R58jx5gbxAXiAvkBfIC+QF8gJ5gbxAXiQvkhfJi+RF8iJ5kbxIXiQvkpfIS+Ql8hJ5ibxEXiIvkZfIS+Rl8jJ5mbxMXiYvk5fJy+Rl8jJ5qGslUGJKnJJGiVcSlEQlSYnIEBkiQ2SIDJEhMkSGyBAZIpvIJrKJbCKbyCayiWwim8gmshPZiexEdiI7kZ3ITmQnsjSCPIJEgkyCVIJcgmSCbIJ0gnyChIKMgpSCnIKkgqyCtIK8gsSCzILUgtyC5ILsgvSC/IIEgwyDFIMcgySDLIM0gzyDRINMg1SDXINkg2yDdIN8g4SDjIOUg5yDpIOsg7SDvIPEg8yD1IPcg+SD7IP0g/yDBIQMhBTE2cHpUfm9HXftU9/xzfTlNGy/vage/x10Ra+yh3G/7Z5PYzeN+vO1Mvz/Aw==","file_map":{"50":{"source":"use dep::poseidon::poseidon2::Poseidon2::hash;\n\nmod merkle_root;\n\nfn main(\n    root_hash: pub Field,\n    nullifier_hash: pub Field,\n    recipient_address: pub Field,\n    nullifier: Field,\n    secret: Field,\n    merkle_proof: [Field; 32],\n    is_even: [bool; 32],\n    amount: Field,\n) {\n    let commitment: Field = hash([nullifier, secret, amount], 3);\n\n    let computed_nullifier_hash: Field = hash([nullifier], 1);\n\n    assert(computed_nullifier_hash == nullifier_hash, \"Invalid nullifier hash\");\n\n    let computed_merkle_root = merkle_root::compute_merkle_root(commitment, merkle_proof, is_even);\n\n    assert(computed_merkle_root == root_hash, \"Invalid merkle proof\");\n}\n","path":"/Users/obaloluwa/Documents/WEB3 & ZK/Starknet/bittmixx-2/packages/circuits/src/main.nr"},"51":{"source":"use dep::poseidon::poseidon2::Poseidon2::hash;\n\npub(crate) fn compute_merkle_root(\n    leaf: Field,\n    merkle_proof: [Field; 32],\n    is_even: [bool; 32],\n) -> Field {\n    let mut current_hash: Field = leaf;\n\n    for i in 0..32 {\n        let (left, right) = if is_even[i] {\n            (current_hash, merkle_proof[i])\n        } else {\n            (merkle_proof[i], current_hash)\n        };\n\n        current_hash = hash([left, right], 2);\n    }\n\n    current_hash\n}\n","path":"/Users/obaloluwa/Documents/WEB3 & ZK/Starknet/bittmixx-2/packages/circuits/src/merkle_root.nr"},"58":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/obaloluwa/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":[]}